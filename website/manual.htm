
<html>
<body>

<h1>Quake Lenses</h1>

<p>
<a href="index.htm">home</a> | <a href="manual.htm">manual</a> | <a href="gallery.htm">gallery</a> | <a href="download.htm">download</a> | <a href="contact.htm">contact</a>
</p>

<p>
Quake Lenses uses the same techniques and code from <a href="http://strlen.com/gfxengine/fisheyequake/">Fisheye Quake</a>.
</p>

<h3>Standard Projection</h3>
<p>
The standard projection used by all games today is the rectilinear projection.  It is simple to implement and works very well for any field of view less than 120&deg;.  It begins degenerating as it approaches a limit of 180&deg;, resulting in the total compression of the view to the center of the image.
</p>

<h3>Environment Map</h3>
<p>
If you are familiar with online photo panoramas or Google Street View, those are created by placing a camera on a tripod, and taking six pictures for each direction: front, behind, left, right, top, down.  Combining these pictures creates a cubemap, which effectively represents an entire scene from a fixed position.  A cubemap is one of several types of so-called environment maps.  A cube is most commonly used because it is simple and accurate.
</p>
<p>
The game is able to generate a cubemap by rotating the camera in each of the six directions before rendering a 90&deg;x90&deg; standard projection.  To draw the player's view, an intermediate lookup table is used to map a pixel on the screen to a pixel on the cubemap.  The lens is responsible for the structure of the lookup table.
</p>

<h3>Lens</h3>
<p>
In the game, the lens is responsible for directing a ray of light from the environment to a pixel on the screen, or vice versa.  This is called a forward mapping and an inverse mapping, respectively.
<ul>
   <li>Forward: environment to screen coordinates</li>
   <li>Inverse: screen to environment coordinates</li>
</ul>
When defining these mappings, you can choose from the following coordinate systems described in the next sections:
<ul>
   <li>Radial: (radius &harr; optical angle)</li>
   <li>Spherical: (x,y &harr; latitude,longitude)</li>
   <li>Cartesian: (x,y &harr; 3D vector)</li>
   <li>Cubic: (x,y &harr; cubeface,u,v)</li>
</ul>
</p>

<h3>Radial Coordinates</h3>
<p>
This is the simplest coordinate system commonly used to define physical camera lenses.  It describes the relationship between the radial position R on the film and the angle &theta; from the optical axis of the lens.
</p>

<h4>Screen Coordinates</h4>
<p>
The rest of the modes assume the same coordinate systems for the screen, but different coordinate systems for the environment.  The screen uses 2 coordinates (x,y).  The origin (0,0) is at the center of the screen.  Positive x to the right.  Positive y is up.
</p>

<h3>Spherical Coordinates</h3>
<p>
You can use two angles to define a 3D direction.  You may know them by any of the following standard names:
<ul>
   <li>(yaw, pitch)</li>
   <li>(heading, elevation)</li>
   <li>(azimuth &phi;, elevation &theta;)</li>
   <li>(longitude &lambda;, latitude &phi;)</li>
</ul>
Latitude and Longitude are used in Quake Lenses because they have become standard for defining map projections used in cartography.  The open-source project called proj.4 provides many equations that you can directly use in Quake Lenses.  Latitude and Longitude are zero when looking straight ahead along the optical axis.  Positive longitude to right.  Positive latitude is up.
</p>

<h3>Cartesian Coordinates</h3>
<p>
You can also define a 3D direction using a unit vector (x,y,z).  Quake Lenses currently uses a left-handed coordinate system, as is standard in Quake.  Positive z is straight forward.  Positive x is right.  Positive y is up.
</p>

<h3>Cubic Coordinates</h3>
<p>
This is a non-standard coordinate system that allows you to directly refer to a point on a given cubemap face using (side,u,v).  u and v are between 0 and 1.  Positive u is right.  Positive v is down.  The side is an integer with the following enumeration:
<ul>
   <li>0: FRONT</li>
   <li>1: RIGHT</li>
   <li>2: BEHIND</li>
   <li>3: LEFT</li>
   <li>4: TOP</li>
   <li>5: BOTTOM</li>
</ul>
</p>

<h3>Lens Script</h3>
<p>
To create a lens, you must write a Lua script.  The game will look for the following variables and functions in order to build the lookup table for the lens.  
</p>

<p>
<strong>Variables</strong>
<ul>
   <li>hsym : flag horizontal symmetry</li>
   <li>vsym : flag vertical symmetry</li>
   <li>max_hfov : maximum horizontal FOV</li>
   <li>max_vfov : maximum vertical FOV</li>
   <li>hfit_size : width of the image used for horizontal fitting</li>
   <li>vfit_size : height of the screen used for vertical fitting</li>
</ul>
</p>
<p>
<strong>Functions</strong>
<ul>
   <li>init : called when first initialied</li>
   <li>theta_to_r : forward radial projection</li>
   <li>r_to_theta : inverse radial projection</li>
   <li>latlon_to_xy : forward spherical projection</li>
   <li>xy_to_latlon : inverse spherical projection</li>
   <li>ray_to_xy : forward cartesian projection</li>
   <li>xy_to_ray : inverse cartesian projection</li>
   <li>cubemap_to_xy : forward cubic projection</li>
   <li>xy_to_cubemap : inverse cubic projection</li>
</ul>
</p>

<h4>Scaling (Zooming)</h4>
<p>
A lens creates an image of varying size.  It can be 1x1 units, 20x400 units, or even infinitely large.  Due to the wide range of sizes, the game needs to know how to scale it to the screen.  Different scales result in different zoom levels.  There are currently two ways of scaling.
</p>

<p>
When the user specifies an FOV, the game must use a forward map to determine the scale of the image.  It uses the theta_to_r, latlon_to_xy, or ray_to_xy to determine where the edges of the screen should be on the image.  For example, if you have an hfov of 180, you can call latlon_to_xy(0,pi/2) to get the x position of the furthest right position.  For simplicity, the game assumes a centered image, so it just multiplies this by 2 to get the width of the image.  The game then scales the image so that it fits the width of the screen.
</p>

<p>
As an alternative to the FOV, you can explicity specify a maximum width and height of the image created by your lens, using hfit_size and vfit_size, respectively.  The game will then use this instead of the forward map to scale it to the screen.  The user can then type "fit" to scale the image as large as possible to fit the screen.  The user can also type "hfit" or "vfit" to only fit the image horizontally or vertically regardless of cropping.  (The "fit" command automatically determines which one to use to avoid cropping.)
</p>

<h4>Lookup Table construction</h4>
<p>
The game constructs the lookup table in one of two ways.  It will first try to find an inverse function in the lens script.  The game will then convert the position in the lookup table to a screen coordinate (r or xy) and pass it to the inverse map function.  It will then use the returned value to select a pixel from the cubemap.
</p>

<p>
If the game does not find an inverse function, it will use the provided forward map instead.  The game will then iterate through the cubemap, converting the position to an environment coordinate (radial, spherical, cartesian, or cubic) and passing it to the forward function.  It will then convert the returned screen coordinate to a position in the lensmap for storing the cubemap pixel.  This does not guarantee that all the positions in the lensmap will be filled, and will often result in noticeable holes. (Potential improvement: The holes can be filled by drawing a filled quad determined by the corners of the pixel)
</p>

<h4>Lens Symmetry</h4>
<p>
The lookup table takes some time to calculate, and the performance is slowed by using the Lua interpreter instead of C code for the lens mappings.  We can exploit the potential symmetry of the lens to make the calculation up to four times faster.  If the lens is horizontally or vertically symmetric, you can set the hsym or vsym flag to true, respectively.  That way, the game can deduce the rest of the lookup table after calculating a single half or quadrant.
</p>

<h4>Lens API</h4>

</body>
</html>
