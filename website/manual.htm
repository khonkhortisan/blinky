
<html>
<head>
<title>Quake Lenses - Manual</title>
<link rel="stylesheet" href="main.css" />
</head>
<body>
<div id="container">

<h1>Quake Lenses</h1>

<p>
<a href="index.htm">home</a> | <a href="manual.htm">manual</a> | <a href="gallery.htm">gallery</a> | <a href="faq.htm">f.a.q.</a> | <a href="download.htm">download</a> | <a href="contact.htm">contact</a>
</p>

<h3>Background</h3>
<p>
There are many ways to capture a 3D scene on a 2D surface. By standard, a camera uses a rectilinear (<em>azimuthal gnomonic</em>) projection to keep straight lines straight. This uses the simple concept of a pinhole camera, where rays of light are never bent. This projection is limited to about 120 degrees practically.
</p>
<p>
To allow a wider field of view on this pinhole camera construct, you can imagine placing water between the aperture and the film. When light rays enter water from air, it is refracted. This was the first fisheye camera, and they called it this because it creates an image that a fish would see when looking at the sky from the ocean. It is still limited to 180 degrees, but creates a barrel distortion which extends the practical limit of the rectilinear lens. The modern fisheye lenses of today implement the <em>azimuthal equidistant</em> and the <em>azimuthal equisolid</em> projections, which are limited to 360 degrees.
</p>
<p>
The rectilinear (azimuthal gnomonic) continues to dominate 3D applications due to its ease of construction using a frustum projection matrix. Games in particular allow the adjustment of the frustrum's FOV (field of view), which can make the shortcomings of the rectilinear lens noticeable when increasing past 120 degrees.
</p>
<p>
To create a view that better represents a person's ~180 degree horizontal FOV, one can imagine projecting all the light rays onto a sphere around the viewer. The resulting image on this sphere completely represents everything that the viewer can see, and it is called an environment map.  We can "unwrap" this sphere onto a flat frame using projection methods used by cartographers for the earth. 
</p>
<p>
Quake Lenses uses an existing engine modification called <a href="http://strlen.com/gfxengine/fisheyequake/">Fisheye Quake</a>. This creates an environment map on a cube surrounding the viewer, called a cubemap, which can be used the same way as the aforementioned sphere. Each face of the cube is a rectilinear (azimuthal gnomonic) projection. The game is able to render these faces by pointing the camera at each of the faces respective orientations, which becomes straightforward.  This is how online photo panoramas are created, like google street view.
</p>
<p>
All the alternative projections to the rectilinear are better suited to representing wide FOVs. An additional test for the quality of the lens can be done by seeing how motion in the environment is translated to the projection.  Some seem to induce motion-sickness, while the stereographic projections seem to handle motion in a manner analogous to the rectilinear lens, creating a convincing perspective that reacts predictably to motion.
</p>

<h3>Technical Lens Details</h3>
<p>
To draw the player's view, an intermediate lookup table is used to map a pixel on the screen to a pixel on the cubemap.  The lens is responsible for the structure of the lookup table.  In other words, the lens is responsible for directing a ray of light from the environment to a pixel on the screen, or vice versa.  This is called a forward mapping and an inverse mapping, respectively.
<ul>
   <li>Forward: environment to screen coordinates</li>
   <li>Inverse: screen to environment coordinates</li>
</ul>
When defining these mappings, you can choose from the following coordinate systems described in the next sections:
<ul>
   <li>Radial: (radius &harr; optical angle)</li>
   <li>Spherical: (x,y &harr; latitude,longitude)</li>
   <li>Cartesian: (x,y &harr; 3D vector)</li>
   <li>Cubic: (x,y &harr; cubeface,u,v)</li>
</ul>
</p>

<h4>Radial Coordinates</h4>
<p>
This is the simplest coordinate system commonly used to define physical camera lenses.  It describes the relationship between the radial position R on the film and the angle &theta; from the optical axis of the lens.
</p>

<h4>Screen Coordinates</h4>
<p>
The rest of the modes assume the same coordinate systems for the screen, but different coordinate systems for the environment.  The screen uses 2 coordinates (x,y).  The origin (0,0) is at the center of the screen.  Positive x to the right.  Positive y is up.
</p>

<h4>Spherical Coordinates</h4>
<p>
You can use two angles to define a 3D direction.  You may know them by any of the following standard names:
<ul>
   <li>(yaw, pitch)</li>
   <li>(heading, elevation)</li>
   <li>(azimuth &phi;, elevation &theta;)</li>
   <li>(longitude &lambda;, latitude &phi;)</li>
</ul>
Latitude and Longitude are used in Quake Lenses because they have become standard for defining map projections used in cartography.  The open-source project called proj.4 provides many equations that you can directly use in Quake Lenses.  Latitude and Longitude are zero when looking straight ahead along the optical axis.  Positive longitude to right.  Positive latitude is up.
</p>

<h4>Cartesian Coordinates</h4>
<p>
You can also define a 3D direction using a unit vector (x,y,z).  Quake Lenses currently uses a left-handed coordinate system, as is standard in Quake.  Positive z is straight forward.  Positive x is right.  Positive y is up.
</p>

<h4>Cubic Coordinates</h4>
<p>
This is a non-standard coordinate system that allows you to directly refer to a point on a given cubemap face using (side,u,v).  u and v are between 0 and 1.  Positive u is right.  Positive v is down.  The side is an integer with the following enumeration:
<ul>
   <li>0: FRONT</li>
   <li>1: RIGHT</li>
   <li>2: BEHIND</li>
   <li>3: LEFT</li>
   <li>4: TOP</li>
   <li>5: BOTTOM</li>
</ul>
</p>

<h3>Creating a Lua script for the Lens</h3>
<p>
To create a lens, you must write a Lua script.  The game will look for the following variables and functions in order to build the lookup table for the player's view.
</p>

<p>
<strong>Variables</strong>
<ul>
   <li>hsym = boolean : flag horizontal symmetry</li>
   <li>vsym = boolean : flag vertical symmetry</li>
   <li>max_hfov  =  number : maximum horizontal FOV</li>
   <li>max_vfov = number : maximum vertical FOV</li>
   <li>hfit_size = number: width of the image used for horizontal fitting</li>
   <li>vfit_size = number : height of the screen used for vertical fitting</li>
</ul>
</p>
<p>
<strong>Functions</strong>
<ul>
   <li>theta_to_r : forward radial projection</li>
   <li>r_to_theta : inverse radial projection</li>
   <li>latlon_to_xy : forward spherical projection</li>
   <li>xy_to_latlon : inverse spherical projection</li>
   <li>ray_to_xy : forward cartesian projection</li>
   <li>xy_to_ray : inverse cartesian projection</li>
   <li>cubemap_to_xy : forward cubic projection</li>
   <li>xy_to_cubemap : inverse cubic projection</li>
   <li>xy_isvalid : inverse check</li>
   <li>r_isvalid : inverse check</li>
</ul>
One way to learn how to use these is to look at the examples in the /lenses folder.  The basic idea is that a function takes in a set of coordinates, and returns a new set of coordinates.  (The coordinate systems are described in the previous sections.)  For example, <em>latlon_to_xy</em> takes two arguments (lat,lon) and returns two arguments (x,y).  <em>xy_to_ray</em> takes two arguments (x,y) and returns three arguments for a ray (rx,ry,rz).  The following sections describe how to structure your lens in more detail.
</p>

<h4>Scaling (Zooming)</h4>
<p>
A lens creates an image of varying size.  It can be anything from 1x1 units to 1000x1000 units, or even infinitely large.  Due to the wide range of sizes, the game needs to know how to scale it to the screen.  Different scales result in different zoom levels.  There are currently two ways of scaling: FOV or fitting.
</p>

<strong>FOV</strong>
<p>
When the user specifies an FOV, the game must use a forward map to determine the scale of the image.  It uses the theta_to_r, latlon_to_xy, or ray_to_xy to determine where the edges of the screen should be on the image.  For example, if you have an hfov of 180, you can call latlon_to_xy(0,pi/2) to get the x position of the furthest right position.  For simplicity, the game assumes a centered image, so it just multiplies this by 2 to get the width of the image.  The game then scales the image so that it fits the width of the screen.
</p>

<strong>Fitting</strong>
<p>
As an alternative to the FOV, you can explicity specify a maximum width and height of the image created by your lens, using hfit_size and vfit_size, respectively.  The game will then use this instead of the forward map to scale it to the screen.  The user can then type "fit" to scale the image as large as possible to fit the screen.  The user can also type "hfit" or "vfit" to only fit the image horizontally or vertically regardless of cropping.  (The "fit" command automatically determines which one to use to avoid cropping.)
</p>

<h4>Lookup Table construction</h4>
<p>
The game constructs the lookup table in one of two ways.  It will first try to find an inverse function in the lens script.  The game will then convert the position in the lookup table to a screen coordinate (r or xy) and check if it is inside the image by calling r_isvalid or xy_isvalid.  If it is not valid it will leave the pixel blank.  If it is valid, it will pass the screen coordinate to the inverse map function.  It will then use the returned value to select a pixel from the cubemap.  
</p>

<p>
If the game does not find an inverse function, it will look for the forward function instead.  The game will then iterate through the cubemap, converting the position to an environment coordinate (radial, spherical, cartesian, or cubic) and passing it to the forward function.  It will then convert the returned screen coordinate to a position in the lensmap for storing the cubemap pixel.  This does not guarantee that all the positions in the lensmap will be filled, and will often result in noticeable holes. (Potential improvement: The holes can be filled by drawing a filled quad determined by the corners of the pixel)
</p>

<h4>Lens Symmetry</h4>
<p>
The lookup table takes some time to calculate, and the performance is slowed by using the Lua interpreter instead of C code for the lens mappings.  We can exploit the potential symmetry of the lens to make the calculation up to four times faster.  If the lens is horizontally or vertically symmetric, you can set the hsym or vsym flag to true, respectively.  That way, the game can deduce the rest of the lookup table after calculating a single half or quadrant.
</p>


</div>
</body>
</html>
